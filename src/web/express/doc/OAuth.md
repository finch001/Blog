# OAuth2.0
OAuth是一个关于授权的开放网络标准，目前的版本是2.0版。

## 应用场景
假设有一个"云冲印"的网站，可以将用户在Google的照片打印出来，用户为了使用改服务，必须让云冲印读取自己存储在Google上的照片
问题在于只有得到用户的授权，Google才会同意"云冲印"读取用户的资料。
传统的做法是让用户将自己的Google用户名和密码，告诉"云冲印"，让后者可以登录Google去读取用户的照片，但是这样做有个问题在于用户的账户信息就这样泄漏了。

OAuth就是为了解决上述问题。

## 名词定义
关于OAuth协议，需要首先了解几个专用名词。
- Third-party application 第三方应用，也就是客户端 云冲印
- Http Service HTTP服务提供商，也就是上述的Google
- Resource Owner 资源拥有者，也就是用户
- User Agent 用户代理
- Authorization Server 认证服务器 即服务提供商专门用来处理认证的服务器。
- Resource server 资源服务器， 即服务提供商存储用户生成的资源的服务器，它和认证服务器可以是一台服务器，也可以是不同的服务器。

## OAuth的思路
OAuth 在客户端和服务提供商之间，设置一个授权层。客户端不能直接登录服务提供商，只能登录授权层，以此将用户和客户端区分开来，这样客户端只能使用授权层的令牌，不同于用户的密码，用户用登录的时候，指定授权层令牌的权限范围和有效期。

## 运行流程
1. 用户打开客户端，客户端要求用户授权
2. 用户同意给予客户端授权
3. 客户单拿到上一步授权，向认证服务器申请令牌
4. 认证服务器对客户端进行认证后，确认无误，同意发放令牌
5. 客户端使用令牌，向资源服务器申请获取资源
6. 资源服务器确认令牌无误后，同意向客户端开发资源


上面步骤关键在于用什么方式来让用户同意授权客户端，只有这样客户端才能获取令牌，进而拿着令牌去获取资源。

## 客户端的授权模式
- 授权码模式
- 简化模式
- 密码模式
- 客户端模式

## 授权码模式
授权码模式是功能最完整也是最严厉的授权模式，它的特点就是通过客户端的后台服务器，与服务提供商的认证服务器进行互动。

1. 用户访问客户端，后者将其引导到认证服务器
2. 用户选择是否给予客户端授权
3. 如果用户同意授权，认证服务器将用户导向客户端事先指定的 "重定向URL"，同时附上一个授权码。
4. 客户端收到授权码，附上早先的 "重定向URL" 向认证服务器申请令牌，这一步是客户端的后台服务器完成，对于用户不可见。
5. 认证服务器核对了授权码和重定向URL，确定无误后，向客户端发送访问令牌和更新令牌

第一步中客户端申请认证的URL需要包含一下参数：
- response_type: 表示授权类型 必选项 此处固定是 "code"
- client_id: 表示客户端的ID   必选项
- redirect_uri 表示重定向URL 可选项
- scope 申请的权限范围
- state 表示客户端的当前状态，服务器会原封不动返回

第三步 服务器返回客户端的URI 包含一下参数：
- code 表示授权码，必选项，该码的有效期应该很短，通常设为10分钟， 该码和客户端ID和重定向URL是一一对应关系。
- state 客户端传给服务器的，服务器也原封不动返回

第四步 客户端向认证服务器申请令牌的HTTP 包含一下参数
- grand_type 表示使用的授权模式，必选项，此处的值固定为"authorization_code"。
- code 表示上一步获取的授权码 必选项
- redirect_uri 表示重定向URL 必填项 和第一步中的参数必须保持一致
- clident_id 表示客户端ID 必填项

第五部，认证服务器发送的HTTP回复，包括一下参数：
- access_token 表示访问令牌 必填项
- token_type 表示令牌类型  该值 大小写不敏感 可是bearer或者mac类型
- expires_in 表示过期时间  单位为秒
- refresh_token 表示更新令牌 可以获取下一次的访问令牌
- scope 表示权限范围







