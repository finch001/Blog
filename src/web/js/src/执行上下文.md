## JavaScript中的执行上下文和执行栈
执行上下文是当前JavaScript代码被解析和执行所在的环境的抽象概念。

### 执行上下文的类型
- 全局执行上下文: 只有一个,浏览器中的全局对象就是window对象，this 只想这个全局对象。
- 函数执行上下文：存在无数个，只要在幻术被调用的时候就会被创建，每一次调用函数都会创建一个新的执行上下文。
- Eval函数执行上下文: 指运行在`eval`函数的代码，一般不怎么建议使用。

###执行栈
执行栈，也叫调用栈，具有LIFO(后进先出)结构，用于存储代码执行过程中的所有执行上下文。

首次运行JS代码时，会创建一个全局执行上下文并push到当前的执行栈中，每当一个新的函数调用，引擎就会创建一个新的上下文并push到当前执行栈的栈顶。

当栈顶函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出来，上下文控制权将移到当前执行栈的下一个执行上下文。

```````js
var a = 'Hello World!';

function first() {  
  console.log('Inside first function');  
  second();  
  console.log('Again inside first function');  
}

function second() {  
  console.log('Inside second function');  
}

first();  
console.log('Inside Global Execution Context');
```````

###执行上下文的创建
执行上下文分两个阶段创建: 1.创建阶段 2. 执行阶段

创建阶段
1. 确定this ，也成为this binding
   - 全局执行上下文  this的值指向全局对象，在浏览器this指向window对象, 而在node环境只想这个文件的Module对象。
   - 函数执行上下文 this的值取决函数的调用方式。 具体：默认绑定 隐式绑定 显示绑定 new绑定 箭头函数  运行时绑定的
2. LexicalEnvironment (词法环境) 被创建
   2.1 环境记录 存储遍历和函数声明的时间位置
   2.2 对外部环境的引用  可以访问的外部此法环境

   全局环境： 主要是window全局对象已经任何用户挂载在window上，this的值指向这个全局对象
   函数环境： 用户在函数中定义的变量被存储在环境记录中,包含了argument对象，外部环境可能是全局环境也可能是其他内部函数的外部函数环境。

3. VariableEnvironment (变量环境) 被创建
在ES6中，词法环境和变量环境的区别在于前者存储 函数声明和变量绑定（let const） 而后者用于存储变量(var) 绑定。
````js
GlobalExectionContext = {
    ThisBinding: <Global Object>
    LexicalEnvironment: {
        EmvironmentRecord:{
            Type: "object",
            a:<uninitialized>
            b:<uninitialized>,
            multiply: <func>
        }
        outer: <null>
    }

    VariableEnvironment: {  
        EnvironmentRecord: {  
            Type: "Object",  
            // 标识符绑定在这里  
            c: undefined,  
        }  
    outer: <null>  
  }
}

FunctionExectionContext = {
    ThisBinding: <Global Object>

     LexicalEnvironment: {  
    EnvironmentRecord: {  
      Type: "Declarative",  
      // 标识符绑定在这里  
      Arguments: {0: 20, 1: 30, length: 2},  
    },  
    outer: <GlobalLexicalEnvironment>  
  },

  VariableEnvironment: {  
    EnvironmentRecord: {  
      Type: "Declarative",  
      // 标识符绑定在这里  
      g: undefined  
    },  
    outer: <GlobalLexicalEnvironment>  
  }
}

````

变量提升： 浏览器执行代码的时候有两个阶段： 1. 编译阶段，此处会扫描变量并将其设置为undefined，如果是let const 会产生代码暂时性死区。2. 然后才是执行阶段。

暂时性死区： 只要作用于存在const let，那么只有声明变量的那一行代码出现，才可以获取和使用，在这之前的获取和使用都会出现ReferenceError错误，也就不存在变量提升。

来一个练习： 判断执行上下文的变化不同
~~~~js
var scope = 'Global scope';
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope()
~~~~

~~~~~js
var scope = 'Global scope';
function checkscope(){
    var scope = "local scope";

    funtion f(){
        return scope;
    }

    return f;
}

checkscope()();

~~~~~

第一段代码变化：
~~~~js
Estack.push(<checkscope> functionContext);
Estack.push(<f> functionContext);
Estack.pop();
Estack.pop();
~~~~


~~~~js
ECStack.push(<checkscope> functionContext);
ECStack.pop();
ECStack.push(<f> functionContext);
ECStack.pop();
~~~~

执行过程： 
执行上下文的代码分为两个阶段来处理：
1. 进入执行上下文
   函数的形参都是：undefined 没有实参
   函数申明 如果存在相同名称的属性，则完全替换这个属性
   变量申明 如果变量存在相同形参或者函数，则变量声明不会干扰已经存在的属性
2. 代码执行
   对于函数而言  变量对象初始化 Arguments对象  将形参替换为实参  初始化函数声明  变量声明等初始的值。
   
